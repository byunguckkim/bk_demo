// Copyright (C) 2022 Applied Intuition, Inc. All rights reserved.
// This source code file is distributed under and subject to the LICENSE in license.txt

syntax = "proto3";

package simian_public.sensor_output;

import "google/protobuf/timestamp.proto";
import "applied/simian/public/proto/sensor_model.proto";
import "applied/simian/public/proto/sensor_sim/basic_types.proto";
import "applied/simian/public/proto/sensor_sim/camera_model.proto";
import "applied/simian/public/proto/spatial.proto";

//
// Top-level a collection of various SensorOutputs generated by
// a physical perception sensor device (e.g Lidar, Radar,
// Camera, Ultrasound).
//
message SensorOutputList {
  // Information about the source sensor that generated the outputs.
  Metadata metadata = 1;

  // Output data structures of the sensor.
  repeated SensorOutput sensor_outputs = 2;
}

//
// Describes metadata and common sensor outputs for the source sensor.
//
message Metadata {
  // Name of source sensor.
  string sensor_name = 1;

  // YAML description of the source sensor's model/specs.
  sensor_model.Description sensor_description = 2;

  // Sensor pose this data was captured with.
  spatial.Pose world_t_sensor = 3;

  // Timestmap when the SensorOututList was generated.
  google.protobuf.Timestamp sim_time = 4;
}

//
// Contains the output data for a specific type of a sensor's output.
//
message SensorOutput {
  // User-defined name for this output.
  string output_name = 1;

  // Output data container from the sensor.
  oneof output_data {
    NDArray ndarray = 2;
    RawPacketStream raw_packet_stream = 3;
    PointCloud point_cloud = 4;
    RawResponse raw_response = 5;
    Image image = 6;
  }
}

//
// Primitive data types (similar to ROS PointField datatype).
//
message DataType {
  enum Enum {
    NOT_SET = 0;
    INT8 = 1;
    UINT8 = 2;
    INT16 = 3;
    UINT16 = 4;
    INT32 = 5;
    UINT32 = 6;
    FLOAT32 = 7;
    FLOAT64 = 8;
  }
}

//
// Container to describe a N-dimensional array of entries of output data.
//
message NDArray {
  // Describes the name, size and byte location of a field within an element of the data
  // (similar to a ROS Field).
  //
  // Example: the following struct:
  // struct {
  //    UINT8   x;
  //    UINT32  y;
  //    FLOAT64 z;
  //  };
  //
  // evaluates to the following NDArray.fields message:
  //              Field{ FieldType, Offset, DataType.Enum }
  //  fields[0] = Field{ NDArray_Field_POSITION_X, 0,  2 }
  //  fields[1] = Field{ NDArray_Field_POSITION_Y, 1,  6 }
  //  fields[2] = Field{ NDArray_Field_POSITION_Z, 5,  8 }
  //
  message Field {
    enum FieldType {
      NOT_SET = 0;
      POSITION_X = 1;  // FLOAT32       | Units: meters         | Hit position[_X] in sensor
      // coordinate frame (Cartesian)
      POSITION_Y = 2;  // FLOAT32       | Units: meters         | Hit position[_Y] in sensor
      // coordinate frame (Cartesian)
      POSITION_Z = 3;  // FLOAT32       | Units: meters         | Hit position[_Z] in sensor
      // coordinate frame (Cartesian)
      INTENSITY = 4;  // FLOAT32       | see sensor_model.LidarModel.LidarDataFormat.IntensityFormat
      CHANNEL_ID = 5;  // UINT32        | Units: none           | ID/index for which laser channel
      // produced the point
      AMBIENT = 6;       // FLOAT32       | Units: dBW            | Background power of a given beam
      VOLTAGE_REAL = 7;  // FLOAT32       | Units: Volt/sqrt(Ohm) | Real part of receiver voltage
      VOLTAGE_IMAGINARY =
          8;  // FLOAT32       | Units: Volt/sqrt(Ohm) | Imaginary part of receiver voltage
      VOLTAGE_MAG =
          9;  // FLOAT32       | Units: Volt/sqrt(Ohm) | Complex magnitude of receiver voltage
      VOLTAGE_ANGLE =
          10;          // FLOAT32       | Units: radians        | Complex angle of receiver voltage
      POWER = 11;      // FLOAT32       | Units: Watt           | Received power (linear scale)
      POWER_DBW = 31;  // FLOAT32       | Units: dBW            | Received power (dBW scale)
      SIGNAL_PHOTONS =
          12;  // FLOAT32       | Units: count          | Detected photon count from returned signal
      AMBIENT_PHOTONS = 13;  // FLOAT32       | Units: count          | Detected photon count from
      // background sources
      TIMESTAMP =
          14;  // FLOAT32       | Units: ms             | Seconds since start of the simulation
      FRAME_ID =
          15;  // UINT32        | Units: none           | Frame number at which sample captured
      RETURN_ID = 16;  // UINT32        | Units: none           | Id for this return for multiple
      // returns per channel
      STATUS = 17;     // UINT32        | Units: none           | Context specific interpretation
      RANGE = 18;      // FLOAT32       | Units: meters         | Range (radial distance)
      AZIMUTH = 19;    // FLOAT32       | Units: degrees        | Azimuth angle
      ELEVATION = 20;  // FLOAT32       | Units: degrees        | Elevation angle
      RADIAL_VELOCITY = 21;  // FLOAT32       | Units: m/s            | Scalar radial velocity
      RADIAL_VELOCITY_X =
          22;  // FLOAT32       | Units: m/s            | Vector radial velocity[_X] (Cartesian)
      RADIAL_VELOCITY_Y =
          23;  // FLOAT32       | Units: m/s            | Vector radial velocity[_Y] (Cartesian)
      RADIAL_VELOCITY_Z =
          24;      // FLOAT32       | Units: m/s            | Vector radial velocity[_Z] (Cartesian)
      DEPTH = 25;  // FLOAT32       | Units: meters         | Depth of the target (in track mode)
      WIDTH = 26;  // FLOAT32       | Units: degrees         | Angular Width of the target (in track
                   // mode)
      HEIGHT = 27;     // FLOAT32       | Units: degrees        | Angular height of the target (in
                       // track mode)
      RCS = 28;        // FLOAT32       | Units: m^2            | Radar cross section (linear scale)
      RCS_DBSQM = 32;  // FLOAT32       | Units: dBsqm          | Radar cross section (dBsqm scale)
      SNR = 29;     // FLOAT32       | Units: none           | Signal-to-noise ratio (linear scale)
      SNR_DB = 33;  // FLOAT32       | Units: dB             | Signal-to-noise ratio (dB scale)
      BLUE = 34;    // FLOAT32       | Units: ~              | Blue channel of a sensor (units
                    // depend on sensor configuration)
      GREEN = 35;   // FLOAT32       | Units: ~              | Green channel of a sensor
                    // (units depend on sensor configuration)
      RED = 36;     // FLOAT32       | Units: ~              | Red channel of a sensor (units
                    // depend on sensor configuration)
      NIR = 37;     // FLOAT32       | Units: ~              | Near-infrared channel of a sensor
                    // (units depend on sensor configuration)
      LWIR = 38;    // FLOAT32       | Units: ~              | Long-wave infrared channel of a
                    // sensor (units depend on sensor configuration)
      ELECTRONS = 39;                 // FLOAT32 | Units: ~ | Count of electrons
      // reserved 40 to 100;             // Reserved for future measurement fields
      GROUND_TRUTH_POSITION_X = 101;  // FLOAT32 | Units: meters | True hit position[_X] not
      // considering noise, in sensor coordinate frame (Cartesian)
      GROUND_TRUTH_POSITION_Y = 102;  // FLOAT32 | Units: meters | True hit position[_Y] not
      // considering noise, in sensor coordinate frame (Cartesian)
      GROUND_TRUTH_POSITION_Z = 103;  // FLOAT32 | Units: meters | True hit position[_Z] not
      // considering noise, in sensor coordinate frame (Cartesian)
      // See
      // https://home.applied.co/manual/spectral/latest/#/sensors_overview/semantic_segmentation/semantic_segmentation?id=semantic-segmentation
      GROUND_TRUTH_SEMANTIC_CLASS =
          104;                         // UINT32  | Units: none  | Context specific interpretation
      GROUND_TRUTH_ACTOR_ID = 105;     // UINT32  | Units: none  | Context specific interpretation
      HIT_NORMAL_X = 106;              // FLOAT32 | Units: none  | Unit normal at hit position[_X]
      HIT_NORMAL_Y = 107;              // FLOAT32 | Units: none  | Unit normal at hit position[_Y]
      HIT_NORMAL_Z = 108;              // FLOAT32 | Units: none  | Unit normal at hit position[_Z]
      HIT_INDEX = 109;                 // UINT32  | Units: none  | Hit index for ray-tracing result
      GROUND_TRUTH_MATERIAL_ID = 110;  // UINT32  | Units: none  | Material ID hit for this return
      WORLD_NORMAL_X = 111;  // FLOAT32 | Units: none  | Unit normal to surface in world frame[_X]
      WORLD_NORMAL_Y = 112;  // FLOAT32 | Units: none  | Unit normal to surface in world frame[_Y]
      WORLD_NORMAL_Z = 113;  // FLOAT32 | Units: none  | Unit normal to surface in world frame[_Z]
      // reserved 114 to 199;   // Reserved for future ground truth fields
    }
    FieldType field_type = 1;

    // Byte offset in the NDArray element.
    uint32 offset = 2;

    DataType.Enum data_type = 3;
  }

  // Fields describing the byte format of the data, sorted in ascending offset order.
  repeated Field fields = 1;

  // Describes the size of each dimension of which to interpret the data.
  // Example: [2, 3, 4] represents an 2 x 3 x 4 array
  repeated uint32 shape = 2;

  // Byte size of a single element.
  uint32 element_stride = 3;

  // Packed output data.
  simian_public.sensor_sim.basic_types.SensorDataOutput sensor_data_output = 4;
}

message RawPacketStream {
  // Number of packets in the data.
  uint32 packet_count = 1;

  // Size in bytes of each individual packet.
  uint32 packet_size = 2;

  // Packed packet data.
  simian_public.sensor_sim.basic_types.SensorDataOutput sensor_data_output = 3;
}

message PointCloud {
  // Point cloud data stored in ndarray message.
  NDArray data = 1;

  // handedness: Specifies which coordinate system handedness to use for positional data fields.
  // (e.g. right-hand rule vs left-hand rule).
  spatial.CoordinateSystemHandedness handedness = 2;
}

message RawResponse {
  // Raw response data stored in ndarray message.
  NDArray data = 1;
}

message Image {
  // Image data stored in ndarray message.
  NDArray data = 1;
  camera_model.CameraIntrinsicParams camera_intrinsic_params = 6;
}
